src/
  args.c:
    // parse args
    #include "ctf.h"
    #include <curl/curl.h> // Include curl header
    
    char *pastebin_api_key = NULL; // Define and initialize pastebin_api_key
    
    void clear_ctf_output_files(void) {
    
        DIR *dir = opendir(".");
        if (!dir) {
            perror("opendir for clearing");
            return;
        }
        struct dirent *entry;
        while ((entry = readdir(dir)) != NULL) {
            if (strncmp(entry->d_name, "ctf-output", strlen("ctf-output")) == 0) {
    
                if (remove(entry->d_name) != 0) {
                    perror("remove ctf-output file");
                }
            }
        }
        closedir(dir);
    }
    
    void load_gitignore(void) {
        FILE *git_ignore_file = fopen(".gitignore", "r");
        if (!git_ignore_file) {
    
            return;
        }
    
        char line[MAX_PATH_SIZE];
        while (fgets(line, sizeof(line), git_ignore_file)) {
    
            line[strcspn(line, "\r\n")] = 0;
    
    
            char *trimmed_line = line;
            while (isspace((unsigned char)*trimmed_line)) trimmed_line++;
    
    
            if (trimmed_line[0] == '\0' || trimmed_line[0] == '#') {
                continue;
            }
    
    
            if (rmf_count < MAX_RMF) {
    
                strncpy(gitignore_entries[rmf_count], trimmed_line, MAX_PATH_SIZE - 1);
                gitignore_entries[rmf_count][MAX_PATH_SIZE - 1] = '\0';
    
                rmf_dirs[rmf_count] = gitignore_entries[rmf_count];
                rmf_count++;
            } else {
                fprintf(stderr, "Warning: Maximum number of ignored paths (%d) reached from .gitignore.\n", MAX_RMF);
                break;
            }
        }
        fclose(git_ignore_file);
    }
    
    void parse_arguments(int argc, char *argv[]) {
        for (int i = 1; i < argc; i++) {
            if (strcmp(argv[i], "--clear") == 0) {
                clear_ctf_output_files();
                printf("Cleared ctf-output files.\n");
                exit(0);
            } else if (strcmp(argv[i], "--content") == 0) {
                content_flag = 1;
                i++;
    
                while (i < argc && argv[i][0] != '-') {
                    if (content_type_count < MAX_CONTENT_TYPES)
                        content_types[content_type_count++] = argv[i];
                    else {
                        fprintf(stderr, "Too many content types specified. Max allowed is %d\n", MAX_CONTENT_TYPES);
                        exit(1);
                    }
                    i++;
                }
                i--;
            } else if (strcmp(argv[i], "--addf") == 0) {
                i++;
                while (i < argc && argv[i][0] != '-') {
                    if (addf_count < MAX_ADDF)
                        addf_dirs[addf_count++] = argv[i];
                    else {
                        fprintf(stderr, "Too many addf directories specified. Max allowed is %d\n", MAX_ADDF);
                        exit(1);
                    }
                    i++;
                }
                i--;
            } else if (strcmp(argv[i], "--rmf") == 0) {
                i++;
                while (i < argc && argv[i][0] != '-') {
                    if (rmf_count < MAX_RMF) {
    
    
    
                        rmf_dirs[rmf_count++] = argv[i];
                    } else {
                        fprintf(stderr, "Too many rmf directories specified. Max allowed is %d\n", MAX_RMF);
                        exit(1);
                    }
                    i++;
                }
                i--;
            } else if (strcmp(argv[i], "--git") == 0) {
                 git_flag = 1;
            } else if (strcmp(argv[i], "--dir") == 0 && i + 1 < argc) {
                strncpy(output_dir, argv[++i], MAX_PATH_SIZE - 1);
                output_dir[MAX_PATH_SIZE - 1] = '\0';
                normalize_path(output_dir);
            } else if (strcmp(argv[i], "--name") == 0 && i + 1 < argc) {
                strncpy(output_name, argv[++i], MAX_PATH_SIZE - 1);
                 output_name[MAX_PATH_SIZE - 1] = '\0';
            } else if (strcmp(argv[i], "--paste") == 0 && i + 1 < argc) { // Added --paste option
                pastebin_api_key = argv[++i];
            } else {
                 fprintf(stderr, "Unknown option or missing argument: %s\n", argv[i]);
    
                 exit(1);
            }
        }
    
        if (addf_count == 0)
            addf_dirs[addf_count++] = ".";
    }
  ctf.h:
    #ifndef CTF_H
    #define CTF_H
    
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <time.h>
    #include <dirent.h>
    #include <sys/stat.h>
    #include <unistd.h>
    #include <ctype.h>
    
    #define MAX_PATH_SIZE 1024
    #define MAX_CONTENT_TYPES 1024
    #define MAX_ADDF 1024
    #define MAX_RMF 1024
    
    extern char *content_types[MAX_CONTENT_TYPES];
    extern int content_type_count;
    
    extern char *addf_dirs[MAX_ADDF];
    extern int addf_count;
    
    extern char *rmf_dirs[MAX_RMF];
    extern int rmf_count;
    extern char gitignore_entries[MAX_RMF][MAX_PATH_SIZE];
    
    extern int content_flag;
    extern int git_flag;
    extern FILE *output;
    
    extern char output_dir[MAX_PATH_SIZE];
    extern char output_name[MAX_PATH_SIZE];
    extern char *pastebin_api_key; // Added for Pastebin API key
    
    extern const char *compiled_exts[];
    extern const char *content_exceptions[];
    
    void parse_arguments(int argc, char *argv[]);
    void load_gitignore(void);
    void clear_ctf_output_files(void);
    
    void traverse_directory(const char *base_path, int depth);
    void print_indent(int depth);
    void write_file_content_inline(const char *filepath, int depth);
    void compute_relative_path(const char *base_path, const char *entry_name, char *rel_path, size_t size);
    int is_excluded_path(const char *rel_path);
    int print_path_hierarchy(const char *path);
    
    int is_compiled_file(const char *filename);
    int is_text_file(const char *filename);
    void normalize_path(char *path);
    int should_show_content(const char *filename);
    char *get_output_filename(void);
    char *upload_to_pastebin(const char *filepath, const char *api_key); // Added for Pastebin upload
    
    #endif
  main.c:
    #include "ctf.h"
    #include <curl/curl.h> // Include curl header
    
    char *content_types[MAX_CONTENT_TYPES];
    int content_type_count = 0;
    
    char *addf_dirs[MAX_ADDF];
    int addf_count = 0;
    
    char *rmf_dirs[MAX_RMF];
    int rmf_count = 0;
    char gitignore_entries[MAX_RMF][MAX_PATH_SIZE];
    
    int content_flag = 0;
    int git_flag = 0;
    FILE *output = NULL;
    
    char output_dir[MAX_PATH_SIZE] = ".";
    char output_name[MAX_PATH_SIZE] = "";
    
    // conpiled file extensions add more to your liking
    const char *compiled_exts[] = {"exe", "bin", "o", "obj", "class", NULL};
    
    // file name exceptions add more to your liking
    const char *content_exceptions[] = {"Dockerfile", NULL};
    
    int main(int argc, char *argv[]) {
        curl_global_init(CURL_GLOBAL_ALL); // Initialize libcurl
        parse_arguments(argc, argv);
    
        if (git_flag) {
            load_gitignore();
        }
    
        char *filename = get_output_filename();
        if (!filename) {
            fprintf(stderr, "Failed to allocate output filename.\n");
            return 1;
        }
        output = fopen(filename, "w");
        if (!output) {
            perror("fopen");
            free(filename);
            return 1;
        }
    
        int traversed = 0;
        for (int i = 0; i < addf_count; i++) {
            int skip = 0;
            for (int j = 0; j < rmf_count; j++) {
                if (strcmp(addf_dirs[i], rmf_dirs[j]) == 0) {
                    skip = 1;
                    break;
                }
            }
            if (skip)
                continue;
    
            int depth = print_path_hierarchy(addf_dirs[i]);
            traverse_directory(addf_dirs[i], depth);
            traversed = 1;
        }
    
        fclose(output);
    
        if (traversed) {
            if (pastebin_api_key) {
                char *paste_url = upload_to_pastebin(filename, pastebin_api_key);
                if (paste_url) {
                    printf("Output uploaded to: %s\n", paste_url);
                    free(paste_url);
                    remove(filename); // Remove the local file after successful upload
                } else {
                    fprintf(stderr, "Failed to upload to Pastebin. Output saved locally to %s\n", filename);
                }
            } else {
                printf("Output written to %s\n", filename);
            }
        } else {
            printf("No directories traversed or all were excluded.\n");
            remove(filename); // Remove the empty file
        }
    
        free(filename);
        curl_global_cleanup(); // Cleanup libcurl
        return 0;
    }
  pastebin.c:
    // src/pastebin.c
    #include "ctf.h"
    #include <curl/curl.h>
    #include <sys/stat.h>
    
    // Helper struct for curl write callback
    struct MemoryStruct {
        char *memory;
        size_t size;
    };
    
    // Callback function for curl to write received data into memory
    static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
        size_t realsize = size * nmemb;
        struct MemoryStruct *mem = (struct MemoryStruct *)userp;
    
        char *ptr = realloc(mem->memory, mem->size + realsize + 1);
        if(ptr == NULL) {
            /* out of memory! */
            fprintf(stderr, "not enough memory (realloc returned NULL)\n");
            return 0;
        }
    
        mem->memory = ptr;
        memcpy(&(mem->memory[mem->size]), contents, realsize);
        mem->size += realsize;
        mem->memory[mem->size] = 0;
    
        return realsize;
    }
    
    // Function to upload file content to Pastebin
    char *upload_to_pastebin(const char *filepath, const char *api_key) {
        CURL *curl;
        CURLcode res;
        struct MemoryStruct chunk;
        chunk.memory = malloc(1); // Start with 1 byte, will be grown by realloc
        chunk.size = 0;           // No data yet
    
        FILE *file = fopen(filepath, "rb");
        if (!file) {
            perror("fopen for pastebin upload");
            free(chunk.memory);
            return NULL;
        }
    
        // Get file size
        struct stat st;
        if (stat(filepath, &st) != 0) {
            perror("stat for pastebin upload");
            fclose(file);
            free(chunk.memory);
            return NULL;
        }
        long file_size = st.st_size;
    
        // Read file content
        char *file_content = malloc(file_size + 1);
        if (!file_content) {
            fprintf(stderr, "Failed to allocate memory for file content\n");
            fclose(file);
            free(chunk.memory);
            return NULL;
        }
        // Cast file_size to size_t for comparison with fread's return value (size_t)
        if (fread(file_content, 1, file_size, file) != (size_t)file_size) {
            fprintf(stderr, "Failed to read entire file content\n");
            fclose(file);
            free(file_content);
            free(chunk.memory);
            return NULL;
        }
        file_content[file_size] = '\0';
        fclose(file);
    
        curl = curl_easy_init();
        if(curl) {
            // Extract filename for paste name
            const char *filename_only = strrchr(filepath, '/');
            if (!filename_only) {
                filename_only = strrchr(filepath, '\\'); // Handle Windows paths
            }
            filename_only = filename_only ? filename_only + 1 : filepath;
    
            // URL encode the file content
            char *encoded_content = curl_easy_escape(curl, file_content, 0);
            if (!encoded_content) {
                fprintf(stderr, "Failed to URL-encode file content\n");
                free(file_content);
                free(chunk.memory);
                curl_easy_cleanup(curl);
                return NULL;
            }
            free(file_content); // Free original content now
    
            // Prepare POST data string format
            const char *post_format = "api_dev_key=%s&api_option=paste&api_paste_code=%s&api_paste_private=0&api_paste_name=%s&api_paste_format=text";
    
            // Calculate required length for the final POST data string
            int post_data_len = snprintf(NULL, 0, post_format,
                                         api_key, encoded_content, filename_only);
    
            // Allocate memory for the POST data
            char *post_data = malloc(post_data_len + 1);
            if (!post_data) {
                 fprintf(stderr, "Failed to allocate memory for post data\n");
                 curl_free(encoded_content);
                 free(chunk.memory);
                 curl_easy_cleanup(curl);
                 return NULL;
            }
    
            // Construct the final POST data string
            snprintf(post_data, post_data_len + 1, post_format,
                     api_key, encoded_content, filename_only);
    
            curl_free(encoded_content); // Free encoded content now
    
            // Set curl options
            curl_easy_setopt(curl, CURLOPT_URL, "https://pastebin.com/api/api_post.php");
            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
            curl_easy_setopt(curl, CURLOPT_USERAGENT, "libcurl-agent/1.0");
    
            // Perform the request
            res = curl_easy_perform(curl);
    
            free(post_data); // Free post data after use
    
            // Check for errors
            if(res != CURLE_OK) {
                fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
                free(chunk.memory);
                chunk.memory = NULL; // Indicate failure by returning NULL
            } else {
                // Check if Pastebin returned an error message
                if (strncmp(chunk.memory, "Bad API request", 15) == 0) {
                     fprintf(stderr, "Pastebin API Error: %s\n", chunk.memory);
                     free(chunk.memory);
                     chunk.memory = NULL;
                }
                // Pastebin returns the URL on success
            }
    
            curl_easy_cleanup(curl);
        }
    
        return chunk.memory; // Return the URL or NULL
    }
  traverse.c:
    // this file add some useful functions for traversing directories and files
    
    #include "ctf.h"
    
    void print_indent(int depth) {
        for (int i = 0; i < depth; i++) {
            fprintf(output, "  ");
        }
    }
    
    void write_file_content_inline(const char *filepath, int depth) {
        FILE *f = fopen(filepath, "r");
        if (!f) return;
    
        char line[1024];
        while (fgets(line, sizeof(line), f)) {
            print_indent(depth);
            fprintf(output, "%s", line);
        }
    
        fseek(f, -1, SEEK_END);
        if (fgetc(f) != '\n') {
            fprintf(output, "\n");
        }
        fclose(f);
    }
    
    void compute_relative_path(const char *base_path, const char *entry_name, char *rel_path, size_t size) {
    
        if (strcmp(base_path, ".") == 0) {
            snprintf(rel_path, size, "%s", entry_name);
        } else {
            snprintf(rel_path, size, "%s/%s", base_path, entry_name);
        }
        normalize_path(rel_path);
    }
    
    int is_excluded_path(const char *rel_path) {
        char normalized_rel_path[MAX_PATH_SIZE];
        strncpy(normalized_rel_path, rel_path, MAX_PATH_SIZE -1);
        normalized_rel_path[MAX_PATH_SIZE - 1] = '\0';
        normalize_path(normalized_rel_path);
    
        for (int i = 0; i < rmf_count; i++) {
            char normalized_rmf[MAX_PATH_SIZE];
            strncpy(normalized_rmf, rmf_dirs[i], MAX_PATH_SIZE - 1);
            normalized_rmf[MAX_PATH_SIZE - 1] = '\0';
            normalize_path(normalized_rmf);
    
    
            size_t rmf_len = strlen(normalized_rmf);
            if (strncmp(normalized_rel_path, normalized_rmf, rmf_len) == 0) {
    
                if (normalized_rel_path[rmf_len] == '\0' || normalized_rel_path[rmf_len] == '/') {
                    return 1;
                }
            }
    
            if (normalized_rmf[rmf_len - 1] == '/') {
                 if (strncmp(normalized_rel_path, normalized_rmf, rmf_len -1) == 0 && normalized_rel_path[rmf_len - 1] == '/') {
                     return 1;
                 }
            }
        }
        return 0;
    }
    
    void traverse_directory(const char *base_path, int depth) {
        DIR *dir = opendir(base_path);
        if (!dir) {
    
            struct stat st;
            if (stat(base_path, &st) == 0 && S_ISREG(st.st_mode)) {
    
            } else {
                perror("opendir");
            }
            return;
        }
    
        struct dirent *entry;
        char current_rel_path[MAX_PATH_SIZE];
    
        while ((entry = readdir(dir)) != NULL) {
            char full_path[MAX_PATH_SIZE];
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;
    
    
            snprintf(full_path, sizeof(full_path), "%s/%s", base_path, entry->d_name);
            normalize_path(full_path);
    
    
            compute_relative_path(base_path, entry->d_name, current_rel_path, sizeof(current_rel_path));
    
    
            if (is_excluded_path(current_rel_path)) {
                continue;
            }
    
            char *output_filename_ptr = get_output_filename();
            if (output_filename_ptr) {
                char normalized_output_path[MAX_PATH_SIZE];
                const char *output_basename = strrchr(output_filename_ptr, '/');
                output_basename = output_basename ? output_basename + 1 : output_filename_ptr;
    
                // Check required length first to prevent truncation
                int required_len = snprintf(NULL, 0, "%s/%s", output_dir, output_basename);
    
                if (required_len >= 0 && required_len < MAX_PATH_SIZE) {
                    // Safe to write: required length is checked above.
                    snprintf(normalized_output_path, MAX_PATH_SIZE, "%s/%s", output_dir, output_basename);
                    normalize_path(normalized_output_path);
                    if (strcmp(full_path, normalized_output_path) == 0) {
                        free(output_filename_ptr);
                        continue;
                    }
                } else if (required_len >= MAX_PATH_SIZE) {
                     fprintf(stderr, "Warning: Path for output file comparison is too long: %s/%s\n", output_dir, output_basename);
    
    
                }
    
    
                free(output_filename_ptr);
            }
    
    
            struct stat st;
            if (stat(full_path, &st) != 0) {
                perror("stat");
                continue;
            }
    
            if (S_ISDIR(st.st_mode)) {
                print_indent(depth);
                fprintf(output, "%s/\n", entry->d_name);
                traverse_directory(full_path, depth + 1);
            } else {
    
                if (strcmp(entry->d_name, "ctf") == 0 || strcmp(entry->d_name, "ctf.exe") == 0) continue;
    
                print_indent(depth);
                if (should_show_content(entry->d_name)) {
                    fprintf(output, "%s:\n", entry->d_name);
                    write_file_content_inline(full_path, depth + 1);
                } else {
                    fprintf(output, "%s\n", entry->d_name);
                }
            }
        }
        closedir(dir);
    }
    
    int print_path_hierarchy(const char *path) {
        char copy[MAX_PATH_SIZE];
        strncpy(copy, path, MAX_PATH_SIZE);
        copy[MAX_PATH_SIZE - 1] = '\0';
        normalize_path(copy);
    
    
        if (strcmp(copy, ".") == 0) {
            return 0;
        }
    
    
        struct stat st;
        if (stat(path, &st) != 0) {
    
             return 0;
        }
    
    
        char *last_slash = strrchr(copy, '/');
        if (S_ISREG(st.st_mode) && last_slash != NULL) {
            *last_slash = '\0';
    
            if (strcmp(copy, ".") == 0) return 0;
        } else if (S_ISREG(st.st_mode)) {
    
            return 0;
        }
    
        int depth = 0;
        char *token = strtok(copy, "/");
        while (token != NULL) {
            print_indent(depth);
            fprintf(output, "%s/\n", token);
            depth++;
            token = strtok(NULL, "/");
        }
        return depth;
    }
  utils.c:
    // its what you expect from a utils file
    #include "ctf.h"
    
    int is_compiled_file(const char *filename) {
        const char *ext = strrchr(filename, '.');
        if (!ext) {
    
            for (int i = 0; content_exceptions[i] != NULL; i++) {
                if (strcmp(filename, content_exceptions[i]) == 0) {
                    return 0;
                }
            }
            return 1;
        }
        ext++;
        for (int i = 0; compiled_exts[i] != NULL; i++) {
            if (strcmp(ext, compiled_exts[i]) == 0)
                return 1;
        }
        return 0;
    }
    
    int is_text_file(const char *filename) {
    
        return !is_compiled_file(filename);
    }
    
    void normalize_path(char *path) {
        for (int i = 0; path[i]; i++) {
            if (path[i] == '\\') {
                path[i] = '/';
            }
        }
    }
    
    int should_show_content(const char *filename) {
        if (!content_flag) return 0;
    
    
        const char *base_filename = strrchr(filename, '/');
        base_filename = base_filename ? base_filename + 1 : filename;
        for (int i = 0; content_exceptions[i] != NULL; i++) {
            if (strcmp(base_filename, content_exceptions[i]) == 0)
                return 1;
        }
    
    
        if (content_type_count == 0) {
            return !is_compiled_file(filename);
        }
    
    
        const char *ext = strrchr(filename, '.');
        if (!ext) return 0;
        ext++;
        for (int i = 0; i < content_type_count; i++) {
            if (strcmp(ext, content_types[i]) == 0)
                return 1;
        }
        return 0;
    }
    
    char *get_output_filename(void) {
        char *filename = malloc(MAX_PATH_SIZE);
        if (!filename) return NULL;
    
        int required_len = -1;
    
        if (strlen(output_name) > 0) {
            // Check required length first to prevent truncation
            required_len = snprintf(NULL, 0, "%s/%s", output_dir, output_name);
            if (required_len >= 0 && required_len < MAX_PATH_SIZE) {
                // Safe to write: required length is checked above.
                snprintf(filename, MAX_PATH_SIZE, "%s/%s", output_dir, output_name);
            } else {
                fprintf(stderr, "Error: Constructed output path is too long: %s/%s\n", output_dir, output_name);
                free(filename);
                return NULL;
            }
        } else {
            time_t now = time(NULL);
            struct tm *t = localtime(&now);
            char timestamp[64];
            strftime(timestamp, sizeof(timestamp), "ctf-output-%Y%m%d-%H%M%S.txt", t);
    
            // Check required length first to prevent truncation
            required_len = snprintf(NULL, 0, "%s/%s", output_dir, timestamp);
            if (required_len >= 0 && required_len < MAX_PATH_SIZE) {
                // Safe to write: required length is checked above.
                snprintf(filename, MAX_PATH_SIZE, "%s/%s", output_dir, timestamp);
            } else {
                fprintf(stderr, "Error: Constructed output path is too long: %s/%s\n", output_dir, timestamp);
                free(filename);
                return NULL;
            }
        }
        normalize_path(filename);
        return filename;
    }
